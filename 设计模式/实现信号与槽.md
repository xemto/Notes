```cpp
// ... 在左边 define
// ... 在右边 use

// define T
template <class ...T>
struct Signal {
	// use T
	std::vector<std::function<void(T...)>> m_callbacks;
	// use T
	void connect(std::function<void(T...)> callback) {
		m_callbacks.push_back(std::move(callback));
	}

	// use T, define t
	void emit(T... t) {
		for(auto &&callback : m_callbacks) {
			callback(t...);
		}
	}
};

struct Input {
	void main_loop() {
		int i;
		while(std::cin >>i) {
			on_input.emit(i);
		}
		on_exit.emit("hello", "world");
	}
	Signal<int> on_input;
	Signal<std::string, std::string> on_exit;
};

struct Bar {
	void on_input(int i) {
	
	}
	void on_exit(std::string msg1, std::string msg2) {
	
	}
};

Input input;
Bar bar;
Foo foo;

input.on_input.connect([&] (int i) {
	bar.on_input(i);
});

input.on_exit.connect([&] (std::string msg1, std::string msg2) {
	bar.on_exit(msg1, msg2);
});
```

如果`on_exit` 函数的签名发生变化，所有绑定函数的地方都需要更改，这个工作量不少，我们可以使用`bind` 函数来优化：
```cpp
template <class MemFn>
auto bind(Bar *bar, MemFn memfn) {
	return [bar, menfn](auto... t) {
		(bar->*memfn)(t...);  // bar 成员函数调用
	}	
}

input.on_exit.connect(bind(&bar, &Bar::on_exit));
```