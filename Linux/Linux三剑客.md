# 正则表达式分类
Linux三剑客主要分为两类
- 基本正则表达式（BRE、basic regular expression），对应元字符有：`^$.[]*`
- 扩展正则表达式（ERE、extend regular expression），ERE在BRE基础上增加了：`(){}?+|` 等字符
## BRE集合
- 匹配字符
- 匹配次数
- 位置锚

|    符号    | 作用                                    |
| :------: | :------------------------------------ |
|    ^     | 用于模式的左侧，如`^oldboy` 匹配以oldbody单词开头的行   |
|    $     | 用于模式的右侧，如 `oldboy$` 匹配以oldboy单词结尾的行   |
|    ^$    | 匹配空行                                  |
|    .     | 匹配任意一个且只有一个字符，不能匹配空行                  |
|    \     | 转义字符，让特殊含义的字符现出原型，还原本义，例如 `\.`  代表小数点 |
|    *     | 匹配前一个字符0次或1次以上                        |
|    .*    | 匹配所有内容                                |
|   ^.*    | 匹配任意多个字符开头的内容                         |
|   .*$    | 匹配任意多个字符结尾的内容                         |
| `[abc]`  | 匹配`[]` 集合内的任意一个字符，a或b或c，可以写`[a-c]`    |
| `[^abc]` | 匹配除^后面的任意字符，a或b或c，^表示对`[abc]`的取反      |
## ERR集合
扩展正则必须用 `grep -E` 才能生效。

|   字符    | 作用                         |
| :-----: | :------------------------- |
|    +    | 匹配前一个字符1次或多次               |
| `[:/]+` | 匹配括号内的`":"` 或者 `/` 字符1次或多次 |
|    ?    | 匹配前一个字符0次或1次               |
|   \|    | 或者，同时过滤多个字符                |
|   ()    | 分组过滤，被括起来的内容表示一个整体         |
| a{n,m}  | 匹配前一个字符最少n次，最多m次           |
|  a{n,}  | 匹配前一个字符最少n次                |
|  a{n}   | 匹配前一个字符正好n次                |
|  a{m}   | 匹配前一个字符最多m次                |
> `grep` 命令使用参数`-E` 即可支持正则表达式。egrep不推荐使用，使用 `grep -E` 替代

# grep
grep 命令是 Linux 系统中最重要的命令之一，功能是从文本文件或管道数据流中筛选匹配的行和数据，如果再配合正则表达式，功能十分强大。

| 参数选项         | 解释说明               |
| ------------ | ------------------ |
| -v           | 排除匹配结果，相当于结果取反     |
| -n           | 显示匹配行与行号           |
| -i           | 不区分大小写             |
| -c           | 只统计匹配的行数           |
| -E           | 使用egrep命令          |
| --color=auto | 为grep过滤结果添加颜色      |
| -w           | 只匹配过滤的单词           |
| -o           | 只输出匹配的内容，而不会输出整行内容 |
实例：
```sh
grep -E "root|async" /tmp/test_grep.txt --color=auto  # 同时过滤出root和sync有关行
```
文本查找对应目录下文本：
```sh
find /data -name "*.txt"
```
通过管道符可以连接操作：
```sh
find /data -name "*.txt" | grep -E "a|x"
```
此时可以查找文件名中存在 a 或者 x 字符的txt文件
## 分组引用
在正则中使用了`()` 时，`\1` 表示从左侧起，第一个括号中的模式所匹配到的字符。
```sh
grep -E "(l..e).*\1" lovers.txt
```
匹配结果：
I ==love== my ==love==r.
He ==love== his ==lover==s.
而 `I like my lover` 则不会被匹配上。
# sed
> 注意sed和awk使用单引号，双引号有特殊解释

sed 是操作、过滤和转换文本内容的强大工具。
常用功能包括结合正则表达式对文件实现快速增删改查，其中查询的功能中最常用的两大功能是过滤（过滤指定字符串）、取行（取出特定行）。
语法：
```sh
sed [选项] [sed内置命令字符] [输入文件]
```
选项：

| 参数选项 | 解释                           |
| ---- | ---------------------------- |
| -n   | 取消默认sed的输出，常与sed内置命令p一起用     |
| -i   | 直接将修改结果写入文件，不用-i sed修改的是内存数据 |
| -e   | 多次编辑，不需要管道符                  |
| -r   | 支持正则拓展                       |
sed 的==内置命令字符==用于对文件进行不同的操作功能，如多文件增删改查。
sed常用内置命令字符：

| sed的内置命令字符  | 解释                             |
| ----------- | ------------------------------ |
| a           | append，对文本追加，在指定行后面添加一行/多行文本   |
| d           | delete，删除匹配行                   |
| i           | insert，表示插入文本，在指定行前添加一行/多行文本   |
| p           | print，打印匹配行的内容，通常p与-n一起用       |
| s/正则/替换内容/g | 匹配正则内容，然后替换内容（支持正则），结果g代表全局匹配  |
sed匹配范围

| 范围          | 解释                                         |
| ----------- | ------------------------------------------ |
| 空地址         | 全文处理                                       |
| 单地址         | 指定文件某一行                                    |
| `/pattern/` | 被模式匹配到的每一行                                 |
| 范围区间        | 10,20 十到二十行，10,+5 第十行向下五行                  |
| 步长          | 1~2，表示1、3、5、7、9行，2~2 两个步长，表示2、4、6、8、10、偶数行 |
## 实例
1. 输出文件的2、3行：
```sh
sed -n '2,3p' a.txt   # p代表打印，必须使用-n，否则会打印所有行
```
2. 匹配特定字符串，匹配含有 linux 的行：
```sh
sed -n "/linux/p" a.txt 
```
3. 删除内容：
```sh
sed "/game/d" a.txt
```
此时不要加`-n` 否则没有输出。如果加上`-i` 则是直接删除文件中的 game 字符串。
也可以删除特定的行，下面的命令是删除第5行到结尾：
```sh
sed '5,$d' a.txt
```
4. 替换内容
```sh
sed 's/My/His/g' a.txt
```
上面的命令将文件中所有的My替换为His。可以使用`-e` 连续操作：
```sh
sed -e 's/My/His/g' -e 's/877278/888/g' a.txt
```
等价于执行了两次替换操作。因为`/` 也是路径分割符，为了省略转义可以自定义替换操作的间隔符：
```sh
sed "s###My###His###g" a.txt
```
5. 追加内容，在文件第2行追加内容：
```sh
sed -i '2a I am using sed command' a.txt
```
如果匹配的是空地址，则在每一行都执行操作：
```sh
sed -i 'a I am using sed command\nIt\'s true' a.txt
```
## 案例
## 取出linux的IP地址
1. 删除网卡信息
![[Pasted image 20241102115632.png]]
```sh
ifconfig eth0 | sed -n '2p'
```
![[Pasted image 20241102115745.png]]
```sh
ifconfig eth0 | sed -n '2p' | sed 's/^.*inet//' | sed 's/netmask.*$//'
```
使用`-e` 替换管道符：
```sh
ifconfig eth0 | sed -ne '2s/^.*inet//g' -e '2s/net.*//gp'
```
# awk
awk语法：
```sh
awk [option] 'pattern{action}' file ...
```
 awk默认以空格为分割符，且多个空格也识别为一个空格，作为分割符。awk是按行处理文件，一行处理完毕，处理下一行。
awk在处理每一行时，使用分割符将一行数据进行切割，将切割后的数据赋给内置变量 `$1`、`$2`、`$3`...。
- `$0` 表示整行
- `$n` 当前记录的第n个字段
- FS 字段分割符，默认是空格
- `NF` (Number of fields)表示当前分割后的最后一列，倒数第二列可以写成`$(NF-1)`
- `NR` (Number of records) 当前记录数，行数。例如显示文件第二行和第五行：`awk 'NR==2,NR==5' pd.txt`
> awk 必须外层单引号，内层双引号。内置变量`$1`、`$2` 都不得添加双引号，否则会识别为文本

```sh
awk '{print "第一列", $1, "第二列", $2}' a.txt
```

| 参数   | 解释                         |
| ---- | -------------------------- |
| -F   | 指定分割字段符，例如 `awk -F '#'`    |
| -OFS | 指定输出分割符，-OFS='#'，通常结合 -v使用 |
| -v   | 定义或修改一个awk内部的变量            |
| -f   | 从脚本中读取awk命令                |
对于awk而言，变量分为
- 内置变量
- 自定义变量

| 内置变量     | 解释                           |
| -------- | ---------------------------- |
| FS       | 输入字段分割符，默认为空白字符              |
| OFS      | 输出字段分割符，默认为空白字符              |
| RS       | 输入记录分割符，指定输入时的换行符            |
| ORS      | 输出记录分割符，输出时用指定符号代替换行符        |
| NF       | NF: number of field，当前行的字段个数 |
| NR       | NR: number of row，行号         |
| FNR      | 各文件分别计数的行号                   |
| FILENAME | 当前文件名                        |
| ARGC     | 命令行参数的个数                     |
| ARGV     | 数组，保存的是命令行所给定的各参数            |

 ##  实例
1. 打印第一列数字：
```sh
awk '{print $1}' a.txt 
```
2. 统计数字和，统计第一列数字和：
```sh
awk '{sum+=$1};END{print sum}' a.txt
```
3. 打印第五行，`NR==5` 被称为模式
```sh
awk 'NR==5{print $0}' a.txt
```
4. 给每一行内容加上行号
```sh
awk '{print NR,$0}' a.txt
```
5. 使用模式：
```sh
awk 'BEGIN{print "开始使用awk"}{print $0}' a.txt
```
BEGIN模式代表在处理数据前，先执行一些动作。
## awk格式化输出
在awk中输出可以使用print和printf，其中printf需要指定format
```sh
awk '{printf “%s\n”, $1}' a.txt
```
# sort
