在函数体内存在`co_return` 或者`co_yield` 即为协程函数。
对C++20的协程，最简单的理解协程是可以重入的特殊函数。就是这个函数在执行的过程，可以（通过`co_await`  ,或者`co_yield` ）挂起，然后在外部（通过`coroutine_handle` ）恢复运行。
# 协程是特殊的函数
首先再次强调，C++ 20的协程是一个特殊函数。只是这个函数具有挂起和恢复的能力，可以被挂起（挂起后调用代码继续向后执行），而后可以继续恢复其执行。如下图：
![[Pasted image 20241027040343.png]]

如图所示，协程并没有一次执行完成，可以被反复挂起，挂起后可以恢复到挂起的点继续运行。

C++ 的编译器如何识别协程函数呢？是通过函数返回值。C++ 协程函数的返回类型有要求，返回类型是 `Result` ，而 `Result`里面必须有一个子类型承诺对象（`Promise`），呈现为`Result::promise_type`。承诺对象（`Promise`）是一个接口，里面实现`get_return_object` 等接口。而通过`std::coroutine_handle<promise_type>::from_promise( Promise& p )` 这个静态函数，我们可以得到协程句柄（coroutine handle）。而协程的运行状态 ，协程函数的形参，内部变量，临时变量，挂起暂停在什么点，被保存在协程状态 (coroutine state)中。
看了上面的描述，我们可以看出协程的几个重要概念。
- 协程状态 (coroutine state)，记录协程状态，是分配于堆的内部对象：
	- 承诺对象(`Promise`)
	- 形参（协程函数的参数）
	- 协程挂起的点
	- 临时变量
- 承诺对象（`Promise`），从协程内部操纵。协程通过此对象提交其结果或异常。
- 协程句柄（coroutine handle），协程的唯一标示。用于恢复协程执行或销毁协程帧。
- 等待体（awaiter），`co_await` 关键字调用的对象。
## 协程状态
协程状态（coroutine state）是协程启动开始时，`new` 空间存放协程状态，协程状态记录协程函数的参数，协程的运行状态，变量。挂起时的断点。
## 承诺对象
承诺对象的表现形式必须是 `Result::promise_type`，`Result` 为协程函数的返回值类型。
承诺对象是一个实现若干接口，用于辅助协程，构造协程函数返回值；提交传递`co_yield` ，`co_return` 的返回值。明确协程启动阶段是否立即挂起；以及协程内部发生异常时的处理方式。其接口包括：
- `auto get_return_object()`  ：用于生成协程函数的返回对象。
- `auto initial_suspend()` ：用于明确初始化后，协程函数的执行行为，返回值为等待体（`awaiter`），用 `co_wait` 调用其返回值。返回值为 `std::suspend_always` 表示协程启动后立即挂起（不执行第一行协程函数的代码），返回 `std::suspend_never` 表示协程启动后不立即挂起。（当然既然是返回等待体，你可以自己在这儿选择进行什么等待操作）
- `void return_value(T v)` ：调用 `co_return v` 后会调用这个函数，可以保存 `co_return` 的结果
- `auto yield_value(T v)` ：调用 `co_yield` 后会调用这个函数，可以保存 `co_yield` 的结果，其返回其返回值为 `std::suspend_always` 表示协程会挂起，如果返回 `std::suspend_never` 表示不挂起。
- `auto final_suspend() noexcept`：在协程退出是调用的接口，返回 `std::suspend_never` ，自动销毁 coroutine state 对象。若 `final_suspend` 返回 `std::suspend_always` 则需要用户自行调用 `handle.destroy()` 进行销毁。但值得注意的是返回 `std::suspend_always` 并不会挂起协程。
前面我们提到在协程创建的时候，会 `new` 协程状态（coroutine state）。你可以通过可以在 `promise_type` 中重载 `operator new` 和 `operator delete`，使用自己的内存分配接口。
## 协程句柄
协程句柄（coroutine handle）是一个协程的标示，用于操作协程恢复，销毁的句柄。
协程句柄的表现形式是 `std::coroutine_handle<promise_type>`，其模板参数为承诺对象（`promise`）类型。句柄有几个重要函数：
- `resume` 函数可以恢复协程
- `done()`函数可以判断协程是否已经完成。返回 `false` 标示协程还没有完成，还在挂起。
协程句柄和承诺对象之间是可以相互转化的。
- `std::coroutine_handle<promise_type>::from_promise`  ： 这是一个静态函数，可以从承诺对象（`promise`）得到相应句柄。
- `std::coroutine_handle<promise_type>::promise()`  函数可以从协程句柄coroutine handle得到对应的承诺对象（`promise`）
## 等代体(awaiter)
`co_wait` 关键字会调用一个等待体对象(`awaiter`)。这个对象内部也有3个接口。根据接口`co_wait` 决定进行什么操作。
- `bool await_ready()`：等待体是否准备好了，返回 `false` ，表示协程没有准备好，立即调用`await_suspend`。返回 `true`，表示已经准备好了。
- `auto await_suspend(std::coroutine_handle<> handle)`如果要挂起，调用的接口。其中`handle` 参数就是调用等待体的协程，其返回值有3种可能
	- `void` 同返回 `true`
	- `bool` 返回 `true` 立即挂起，返回 `false` 不挂起。
	- 返回某个协程句柄（coroutine handle），立即恢复对应句柄的运行。
- `auto await_resume()` ：协程挂起后恢复时，调用的接口。返回值作为 `co_wait` 操作的返回值。
等待体（`awaiter`）值得用更加详细的笔墨书写一章，我们就放一下，先了解其有2个特化类型。
- `std::suspend_never`类，不挂起的的特化等待体类型。
- `std::suspend_always`类，挂起的特化等待体类型。
## co_await awaiter的用途？
明确说C++20的协程大部分概念还算清晰，就是 `yeild`，然后外部利用句柄 `resume`。对协程这个概念有了解的不应该有什么特别难以理解的地方。但`co_await awaiter`比较让人疑惑。
前面已经讲过，`awaiter` 其实是是一个对象，一个接口实现，其3个接口函数是：
- `await_ready`：等待体是否准备好了，没准备好（`return false`）就调用`await_suspend`
- `await_suspend`：等待体挂起如何操作。参数为调用其的协程句柄。`return true` ，或者 `return void` 就会挂起协程。
- `await_resume`：协程挂起后恢复时，调用的接口，同时返回其结果，作为`co_await`的返回值。
不少代码的例子都是在 `await_suspend` 函数中，直接把` handle.resume()`，就是说这些例子都是在挂起时就理解恢复了协程运行，这样的例子貌似什么异步的感觉都没有，没有体现任何异步操作的效果和优势。
这样 `co_await awaiter`能用来干啥就有点让我好奇了。我的直觉是等待体 `awaiter` 在 `await_suspend` 应该就是记录协程句柄，同时发起一个异步操作（比如用一个线程完成文件读写），然后在异步操作完成后，恢复协程的运行，告知协程读写的结果。
`co_await awaiter` 在未来应该会有很多种等待体，比如AIO，异步网络，异步读写数据库等。这也应该是未来C++协程重点反正发展地方。


```cpp
struct SuspendAlways {
	// 1.
	constexpr bool await_ready() const noexcept { return false; }
	// 2. 返回 void 则 resume() 结束
	constexpr void await_suspend(std::coroutine_handle<> coroutine) const noexcept {}
	// 
	constexpr void await_resume() const noexcept {}
};

struct SuspendNever {
	// 1. 
	constexpr bool await_ready() const noexcept { return true; }

	constexpr void await_suspend(std::coroutine_handle<> coroutine) const noexcept {}
	// 2.
	constexpr void await_resume() const noexcept } {}
};

struct Promise {
	auto initial_suspend() {
		return SuspendNever();
	}

	auto final_suspend() noexcept {
		return SuspendAlways();
	}

	void unhandled_exception() {
		throw;
	}

	void return_void() {
		// 对应 co_return
	}

	void return_value(int ret) {
		// 对应 co_return 42;
		mRetValue = ret;
	}

	auto yield_value(int ret) {
		// 对应 co_yield 42
		mRetValue = ret;
		// 返回suspend_always 时，总会停一下
		return std::suspend_always();
	}
	
	std::coroutine_handle<Promise> get_return_object() {
		return std::coroutine_handle<Promise>::from_promise(*this);
	}

	int mRetValue;
};

struct Task {
	using promise_type = Promise; // 必须使用 promise_type

	Task(std::coroutine_handle<promise_type> coroutine) :mCoroutine(coroutine) {}

	std::coroutine_handle<promise_type> mCoroutine;
};

Task hello() {
	co_return;  // 代表协程函数
}

int main() {
	Task t = hello();
	while(!t.mCoroutine.done())
		t.mCoroutine.resume();  // 真正执行hello函数，只能够调用一次
	cout << t.mCoroutine.promise().mRetValue;
	return 0;
}
```